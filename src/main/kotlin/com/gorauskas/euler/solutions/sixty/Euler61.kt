package com.gorauskas.euler.solutions.sixty

import com.gorauskas.euler.EulerSolution
import com.gorauskas.euler.functions.timer
import com.gorauskas.euler.sequences.permutations

// @Suppress("MagicNumber")
class Euler61 : EulerSolution {
    private fun interface FigurateFunction {
        operator fun invoke(n: Int): Int
    }

    private val figurateFunctions = listOf<FigurateFunction>(
        FigurateFunction { n -> n * (n + 1) / 2 }, // Triangle
        FigurateFunction { n -> n * n }, // Square
        FigurateFunction { n -> n * (3 * n - 1) / 2 }, // Pentagonal
        FigurateFunction { n -> n * (2 * n - 1) }, // Hexagonal
        FigurateFunction { n -> n * (5 * n - 3) / 2 }, // Heptagonal
        FigurateFunction { n -> n * (3 * n - 2) }, // Octagonal
    )

    private val figurateNumbers = figurateFunctions.map { fn ->
        generateSequence(1) { it + 1 }
            .map { fn(it) }
            .takeWhile { it < 10_000 }
            .filter { it >= 1_000 }
            .toList()
    }

    private val figurateTypeIndices = figurateNumbers.indices.toList()

    override val problem = """
        Project Euler Problem 61
          Cyclical Figurate Numbers

            Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers
            are all figurate (polygonal) numbers and are generated by the following
            formulae:

                Triangle                P3,n=n(n+1)/2           1, 3, 6, 10, 15, ...
                Square                  P4,n=n2                 1, 4, 9, 16, 25, ...
                Pentagonal              P5,n=n(3n−1)/2          1, 5, 12, 22, 35, ...
                Hexagonal               P6,n=n(2n−1)            1, 6, 15, 28, 45, ...
                Heptagonal              P7,n=n(5n−3)/2          1, 7, 18, 34, 55, ...
                Octagonal               P8,n=n(3n−2)            1, 8, 21, 40, 65, ...

            The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
            interesting properties.

            1) The set is cyclic, in that the last two digits of each number is the
               first two digits of the next number (including the last number with the
               first).

            2) Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and
               pentagonal (P5,44=2882), is represented by a different number in the
               set.

            3) This is the only set of 4-digit numbers with this property.

            Find the sum of the only ordered set of six cyclic 4-digit numbers for
            which each polygonal type: triangle, square, pentagonal, hexagonal,
            heptagonal, and octagonal, is represented by a different number in the set.
    """.trimIndent()

    override val answer = """

        Cyclical Figurate Numbers (61):

            The sum of the only ordered set of six cyclic 4-digit numbers for
            which each polygonal type is represented by a different number in
            the set is ${timer { solve() }}
    """.trimIndent()

    override fun solve(): Long {
        var res = 0L

        for (perm in figurateTypeIndices.permutations()) {
            val first = perm.first()
            val rest = perm.drop(1)
            for (num in figurateNumbers[first]) {
                val result = dfs(listOf(num), listOf(first), rest, 1)
                if (result != null) {
                    res = result.sum().toLong()
                    break
                }
            }
        }

        return res
    }

    /**
     * explores candidates by trying to match the next number's prefix
     * with the previous number's suffix.
     */
    fun dfs(sequence: List<Int>, typeSequence: List<Int>, remainingTypes: List<Int>, depth: Int): List<Int>? {
        if (sequence.size == 6) {
            val first = sequence.first()
            val last = sequence.last()
            if (last % 100 == first / 100) return sequence
            return null
        }

        val lastTwo = sequence.last() % 100
        if (lastTwo < 10) return null // disallow values like 0999

        for (type in remainingTypes) {
            for (candidate in figurateNumbers[type]) {
                if (candidate / 100 == lastTwo) {
                    val result = dfs(
                        sequence + candidate,
                        typeSequence + type,
                        remainingTypes - type,
                        depth + 1,
                    )
                    if (result != null) return result
                }
            }
        }

        return null
    }
}
